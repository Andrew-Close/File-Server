<h2>Custom threads</h2>
<div class="step-text">
<p>The <strong>main</strong> thread is a starting place from which you may spawn new threads to perform your tasks. To do that you have to write code to be executed in a separated thread and then start it.</p>
<h5 id="create-custom-threads">Create custom threads</h5>
<p>Java has two primary ways to create a new thread that performs a task you need.</p>
<ul><li><p>by <a class="theory-lookup" href="/learn/step/3583" rel="noopener noreferrer nofollow" target="_blank" title="In Java, the term extend is used in the context of inheritance and type bounds. | When used with a class, it indicates that the class is a subclass of the class it extends, inheriting its properties and methods. This is known as implementation inheritance and allows for code reuse and a hierarchical classification of objects. When used with a type parameter, extends sets an upper bound, meaning the type parameter can only be replaced by a type that is that upper bound or a subtype of it.">extending</a> the <code class="language-java">Thread</code> class and <a class="theory-lookup" href="/learn/step/3539" rel="noopener noreferrer nofollow" target="_blank" title="In Java, overriding is a mechanism that allows a subclass to provide a specific implementation of a superclass method. | When a method is overridden, the name and parameter of the subclass method must be exactly the same as the superclass method. However, the return type can be the same as the superclass method or a subtype of it. This feature is known as the covariant return type. Overriding enables subclasses to redefine behavior inherited from their superclass, allowing them to add their own unique flair to inherited methods.">overriding</a> its <code class="language-java">run</code> method;</p></li></ul>
<pre><code class="language-java">class HelloThread extends Thread {

    @Override
    public void run() {
        String helloMsg = String.format("Hello, I'm %s", getName());
        System.out.println(helloMsg);
    }
}
</code></pre>
<ul><li><p>by implementing the <code class="language-java">Runnable</code> <a class="theory-lookup" href="/learn/step/3615" rel="noopener noreferrer nofollow" target="_blank" title="In Java, an interface is a reference type that contains method declarations and serves as a literal interface between a class inheriting that interface and another class. | Unlike a class, an interface can extend multiple interfaces, and a class can implement multiple interfaces. Interfaces help to abstract from specific classes and emphasize functionality, making software design more reusable and clean. They cannot be instantiated, and the main idea of an interface is declaring functionality. Interfaces are a special kind of class that represents a map (or dictionary) for storing key-value pairs where the type of the key and the type of the stored value are specified. A real-world example of a map is a phone book where keys are the names of your friends, and values are their phone numbers. The Map interface is not a subtype of the Collection interface, but maps are often considered a collection since they are part of the collection framework and have similar methods.">interface</a> and passing the <a class="theory-lookup" href="/learn/step/36545" rel="noopener noreferrer nofollow" target="_blank" title="In Java, an implementation refers to the specific way of implementing a method or an interface. | It provides the concrete functionality for the methods declared in an interface. In the context of the provided passage, there are many implementations of the interface in Java, each backed by different principles. For instance, when you have an interface that represents a map, there might be several classes implementing this interface, each providing a different way to order and store data. Implementations help to extend functionality and maintain backward compatibility in Java.">implementation</a> to the constructor of the <code class="language-java">Thread</code> class.</p></li></ul>
<pre><code class="language-java">class HelloRunnable implements Runnable {

    @Override
    public void run() {
        String threadName = Thread.currentThread().getName();
        String helloMsg = String.format("Hello, I'm %s", threadName);
        System.out.println(helloMsg);
    }
}
</code></pre>
<p>In both cases, you should override the <code class="language-java">run</code> method, which is a regular Java method and contains code to perform a task. What approach to choose depends on the task and on your preferences. If you extend the <code class="language-java">Thread</code> class, you can accept <a class="theory-lookup" href="/learn/step/11523" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a field is a variable that stores data within a class. | It can hold any type of data, including primitive types (such as int, float, boolean) and class types. A class can have multiple fields, and they can have different access modifiers. When a field is declared as static, it belongs to the class itself, rather than to an instance of the class, and shares the same value for all instances. It is a common practice to declare a static field as a global variable to save memory.">fields</a> and methods of the <a class="theory-lookup" href="/learn/step/3583" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a base class, also known as a superclass or parent class, is a class that is extended by another class, known as a subclass or derived class. | It serves as a blueprint for the subclass, providing it with inherited fields and methods. A parent class can have multiple child classes, but a child class can only have one parent class due to Java's single inheritance feature. The parent class reference can be used to refer to any subclass object derived from that superclass. An abstract class is often used as a base class in a hierarchy, and it represents an abstract concept that is used as a base class for subclasses.">base class</a>, but you cannot extend other classes since Java doesn't have multiple-<a class="theory-lookup" href="/learn/step/3583" rel="noopener noreferrer nofollow" target="_blank" title="In Java, inheritance is a mechanism for deriving a new class from an existing one, known as the superclass, allowing the new class to acquire its fields and methods. | This principle enables code reuse and convenient class hierarchy building. Inheritance is indicated by the keyword extends and supports single inheritance, with a superclass potentially having multiple subclasses. However, constructors are not inherited; instead, the superclass's constructor can be invoked from the subclass's constructor using the super() keyword. This mechanism allows developers to build a class hierarchy that simulates many real-world relationships, such as a general to a particular concept.">inheritance</a> of classes.</p>
<p>Here are two objects obtained by the approaches described above accordingly:</p>
<pre><code class="language-java">Thread t1 = new HelloThread(); // a subclass of Thread

Thread t2 = new Thread(new HelloRunnable()); // passing runnable</code></pre>
<p>And here's another way to specify the name of your thread by passing it to the constructor:</p>
<pre><code class="language-java">Thread myThread = new Thread(new HelloRunnable(), "my-thread");</code></pre>
<p>If you are already familiar with <a class="theory-lookup" href="/learn/step/11635" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a lambda expression is a function that is not bound to a name (an anonymous function) and can be assigned to a variable. | It consists of a list of parameters followed by the body that can return a value. Lambda expressions are often used to pass a block of code as data to a method. They allow for more readable and concise code, and can be used in place of method references. Lambda expressions have a special type, and there are several types of lambda expressions defined in the Java standard library, such as Function and Predicate, both located in the java.util.function package.">lambda expressions</a>, you may do the whole thing like this:</p>
<pre><code class="language-java">Thread t3 = new Thread(() -&gt; {
    System.out.println(String.format("Hello, I'm %s", Thread.currentThread().getName()));
});</code></pre>
<p>Now you've created objects for threads, but you're not done yet. To perform the tasks you need, you'll have to start them.</p>
<h5 id="starting-threads">Starting threads</h5>
<p>The class <code class="language-java">Thread</code> has a method called <code class="language-java">start()</code> that is used to start a thread. At some point after you <a class="theory-lookup" href="/learn/step/7762" rel="noopener noreferrer nofollow" target="_blank" title="In Java, invoke refers to the process of calling or executing a method. | When a method is invoked, a new stack frame is created in the call stack to store information about the method execution, such as method parameters, local variables, and intermediate computations. The call stack follows the Last In First Out (LIFO) principle, meaning that the most recently added stack frame will be executed first. The stack frame is removed from the call stack once the method execution is complete. The invocation of methods allows for the creation of complex and modular code in Java.">invoke</a> this method, the method <code class="language-java">run</code> will be invoked automatically, but it'll not happen immediately.</p>
<p>Let's suppose that inside the <strong>main</strong> method you create a <code class="language-java">HelloThread</code> object named <code class="language-java">t</code> and start it.</p>
<pre><code class="language-java">Thread t = new HelloThread(); // an object representing a thread
t.start();</code></pre>
<p>Eventually, it prints something like:</p>
<pre><code class="language-no-highlight">Hello, I'm Thread-0</code></pre>
<p>Here's a picture that explains how a thread actually starts and why it is not happening immediately.</p>
<p> </p>
<p style="text-align: center;"><source media="(max-width: 480px)" srcset="https://ucarecdn.com/9dfe86a1-1880-4e14-9635-015d0091c70c/-/stretch/off/-/resize/480x/-/format/webp/ 1x,https://ucarecdn.com/9dfe86a1-1880-4e14-9635-015d0091c70c/-/stretch/off/-/resize/960x/-/format/webp/ 2x,https://ucarecdn.com/9dfe86a1-1880-4e14-9635-015d0091c70c/-/stretch/off/-/resize/1440x/-/format/webp/ 3x" type="image/webp"/><source media="(max-width: 800px)" srcset="https://ucarecdn.com/9dfe86a1-1880-4e14-9635-015d0091c70c/-/stretch/off/-/resize/800x/-/format/webp/ 1x,https://ucarecdn.com/9dfe86a1-1880-4e14-9635-015d0091c70c/-/stretch/off/-/resize/1600x/-/format/webp/ 2x,https://ucarecdn.com/9dfe86a1-1880-4e14-9635-015d0091c70c/-/stretch/off/-/resize/2400x/-/format/webp/ 3x" type="image/webp"/><source srcset="https://ucarecdn.com/9dfe86a1-1880-4e14-9635-015d0091c70c/-/stretch/off/-/resize/1100x/-/format/webp/ 1x,https://ucarecdn.com/9dfe86a1-1880-4e14-9635-015d0091c70c/-/stretch/off/-/resize/2200x/-/format/webp/ 2x,https://ucarecdn.com/9dfe86a1-1880-4e14-9635-015d0091c70c/-/stretch/off/-/resize/3000x/-/format/webp/ 3x" type="image/webp"/><picture><source media="(max-width: 480px)" srcset="https://ucarecdn.com/9dfe86a1-1880-4e14-9635-015d0091c70c/-/stretch/off/-/resize/480x/-/format/webp/ 1x,https://ucarecdn.com/9dfe86a1-1880-4e14-9635-015d0091c70c/-/stretch/off/-/resize/960x/-/format/webp/ 2x,https://ucarecdn.com/9dfe86a1-1880-4e14-9635-015d0091c70c/-/stretch/off/-/resize/1440x/-/format/webp/ 3x" type="image/webp"/><source media="(max-width: 800px)" srcset="https://ucarecdn.com/9dfe86a1-1880-4e14-9635-015d0091c70c/-/stretch/off/-/resize/800x/-/format/webp/ 1x,https://ucarecdn.com/9dfe86a1-1880-4e14-9635-015d0091c70c/-/stretch/off/-/resize/1600x/-/format/webp/ 2x,https://ucarecdn.com/9dfe86a1-1880-4e14-9635-015d0091c70c/-/stretch/off/-/resize/2400x/-/format/webp/ 3x" type="image/webp"/><source srcset="https://ucarecdn.com/9dfe86a1-1880-4e14-9635-015d0091c70c/-/stretch/off/-/resize/1100x/-/format/webp/ 1x,https://ucarecdn.com/9dfe86a1-1880-4e14-9635-015d0091c70c/-/stretch/off/-/resize/2200x/-/format/webp/ 2x,https://ucarecdn.com/9dfe86a1-1880-4e14-9635-015d0091c70c/-/stretch/off/-/resize/3000x/-/format/webp/ 3x" type="image/webp"/><img alt="start threads diagram" height="95" src="https://ucarecdn.com/9dfe86a1-1880-4e14-9635-015d0091c70c/" width="373"/></picture></p>
<p> </p>
<p>As you may see, there is some delay between starting a thread and the moment when it really starts working (running).</p>
<p>By default, a new thread is running in <strong>non-daemon</strong> mode. Reminder: the difference between <strong>daemon</strong> and <strong>non-daemon</strong> mode is that JVM will not terminate the running program while there are <strong>non-daemon</strong> threads left, whereas the <strong>daemon</strong> threads won't prevent the JVM from terminating.</p>
<p> </p>
<p></p>
<div class="alert alert-warning"><p>Do not confuse the methods <code class="language-java">run</code> and <code class="language-java">start</code>. You must invoke <code class="language-java">start</code> if you'd like to execute your code inside <code class="language-java">run</code> in a separate thread. If you invoke <code class="language-java">run</code> directly, the code will be executed in the thread you call <code class="language-java">run</code> from.</p></div>
<p></p>
<p> </p>
<p> </p>
<p></p>
<div class="alert alert-warning"><p><strong> </strong>If you try to start a thread more than once, the <code class="language-java">start</code> method <a class="theory-lookup" href="/learn/step/3553" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a throw is a keyword used to manually trigger an exception during the execution of a program. | It is used in conjunction with an object that represents the exception. Throwing an exception is typically done when a method's preconditions are broken and the method cannot be executed under the current conditions. The object thrown can be of any class or its subclass. It is important to note that simply creating an exception object does not cause it to be thrown; the throw keyword must be used explicitly for this purpose.">throws</a> <code class="language-java">IllegalThreadStateException</code>.</p></div>
<p></p>
<p> </p>
<p>Despite the fact that within a single thread all statements are executed sequentially, it is impossible to determine the relative order of statements between multiple threads without additional measures that we will not consider in this lesson. </p>
<p>Consider the following code:</p>
<pre><code class="language-java">public class StartingMultipleThreads {

    public static void main(String[] args) {
        Thread t1 = new HelloThread();
        Thread t2 = new HelloThread();

        t1.start();
        t2.start();

        System.out.println("Finished");
    }
}</code></pre>
<p>The order of displaying messages may be different. Here is one of them:</p>
<pre><code class="language-no-highlight">Hello, I'm Thread-1
Finished
Hello, I'm Thread-0
</code></pre>
<p>It is even possible that all threads print their text after the <strong>main</strong> thread prints <strong>"Finished":</strong></p>
<pre><code class="language-no-highlight">Finished
Hello, I'm Thread-0
Hello, I'm Thread-1</code></pre>
<p>This means that even though we <a class="theory-lookup" href="/learn/step/10973" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a call refers to the act of instructing the program to execute a specific set of code within a method. | It involves using the method's name and providing the necessary arguments. The method called (or invoked) depends on the passed parameters. If different values are passed to it, the result of the program will also change. However, when calling a function, you should always provide the correct number and type of arguments that the function expects. For instance, if there is another method that takes a student's name, age, and average score as parameters and prints them, the call to this method will depend on the provided parameters. If the application does not throw an exception, a stack trace message will not be displayed. However, a stack trace can be obtained at any specific point by calling the appropriate method, which will return an array.">call</a> the <code class="language-java">start</code> method sequentially for each thread, we do not know when the <code class="language-java">run</code> method will actually be called.</p>
<p> </p>
<p></p>
<div class="alert alert-warning"><p>Do not rely on the order of execution of statements between different threads, unless you've taken special measures.</p></div>
<p></p>
<p> </p>
<h5 id="a-simple-multithreaded-program">A simple multithreaded program</h5>
<p>Let's consider a simple multithreaded program with two threads. The first thread reads numbers from the standard input and prints out their squares. At the same time, the <strong>main</strong> thread occasionally prints messages to the standard output. Both threads work simultaneously.</p>
<p>Here is a thread that reads numbers in a <a class="theory-lookup" href="/learn/step/3505" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a loop is a programming construct that allows you to repeatedly execute a block of code either a fixed number of times or until a certain condition is met. | There are several types of loops in Java, including the for-loop, while-loop, and do-while loop. The for-loop is often used when the number of iterations is known, while the while and do-while loops are used when the number of iterations is unknown or variable. The for-each loop is a specific type of for-loop that is commonly used to iterate through each element of an array, string, or collection without using an index. Loops can be useful for performing various algorithms, iterating through arrays, and reading input from the standard input.">loop</a> and squares them. It has a break statement to stop the loop if the given number is 0.</p>
<pre><code class="language-java">class SquareWorkerThread extends Thread {
    private final Scanner scanner = new Scanner(System.in);

    public SquareWorkerThread(String name) {
        super(name);
    }

    @Override
    public void run() {
        while (true) {
            int number = scanner.nextInt();
            if (number == 0) {
                break;
            }
            System.out.println(number * number);
        }
        System.out.println(String.format("%s finished", getName()));
    }
}</code></pre>
<p>Inside the <code class="language-java">main</code> method, the program starts execution of an object of the <code class="language-java">SquareWorkerThread</code> class and writes messages to the <a class="theory-lookup" href="/learn/step/9055" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a standard output is a receiver to which a program can send information in the form of text. | It is supported by all common operating systems and Java provides a special object, `System.out`, to work with the standard output. This object is often used to print data, with the `println()` method displaying the passed string followed by a new line on the screen. Standard output is a way for a program to write data to a destination, which can be a console, a file, or even a web socket. It is important to note that there are two types of streams: byte and character.">standard output</a>.</p>
<pre><code class="language-java">public class SimpleMultithreadedProgram {

    public static void main(String[] args) {
        Thread worker = new SquareWorkerThread("square-worker");
        worker.start(); // start a worker (not run!)

        for (long i = 0; i &lt; 5_555_555_543L; i++) {
            if (i % 1_000_000_000 == 0) {
                System.out.println("Hello from the main thread!");
            }
        }
    }
}</code></pre>
<p>Here is an example of inputs and outputs with <a class="theory-lookup" href="/learn/step/3520" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a comment is a piece of text that is ignored by the compiler and is used to exclude code from the compilation process or to clarify a piece of code to oneself or other developers. | Java supports three types of comments: end-of-line comments, multi-line comments, and Java documentation comments. End-of-line comments are used to exclude a portion of a line of code, while multi-line comments can be used for both single and multiple lines of code. Java documentation comments, also known as Javadoc, are used to generate API documentation for Java classes, interfaces, and methods.">comments</a>:</p>
<pre><code class="language-java">Hello from the main thread!    // the program outputs it
2                              // the program reads it
4                              // the program outputs it
Hello from the main thread!    // outputs it
3                              // reads it
9                              // outputs it
5                              // reads it
Hello from the main thread!    // outputs it
25                             // outputs it
0                              // reads it
square-worker finished         // outputs it
Hello from the main thread!    // outputs it
Hello from the main thread!    // outputs it

Process finished with exit code 0</code></pre>
<p>As you can see, this program performs two tasks <strong>"at the same time"</strong>:<strong> </strong>one in the <strong>main </strong>thread and another one in the <strong>worker</strong> thread. It may not be  <strong>"the same time"</strong> in the physical sense, however, both tasks are given some time to be executed.</p>
</div>
